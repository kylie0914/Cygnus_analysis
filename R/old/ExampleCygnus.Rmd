---
title: "Example Cygnus Report"
author: "Yein Chung"
date: "2024-08-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

This document is an example Cygnus Report that can be generated at the last step of Cygnus data analysis. Each plot shown in this file is generated when the corresponding R markdown file is knitted to HTML, and hence can be reused with another Cygnus data to generate a similar report. All codes are hidden in the final HTML file to simplify the report.\

```{r compute, echo=FALSE, results='hide', message=FALSE}
library(Cygnus)
library(tidyverse)
library(pheatmap)
library(plotly)
library(Rtsne)
data.path <- "/Users/yeinchung/leelab_2024/Cygnus_test/AIVIA_SEAM_HumanPatient_20231028_Values.csv"
obj <- getCygnus(data.path)
all_markers <- colnames(obj)[6:17] # specific to this data 
meta_markers <- colnames(obj)[18:19]

obj <- createCygnus(obj, all_markers, meta_markers)

plotAvgHeatmap <- function(data, group_column,
                          clustering_distance = "euclidean",
                          colors = rev(colorRampPalette(RColorBrewer::brewer.pal(n = 11, "RdYlBu"))(100)),
                          fontsize = 8,
                          scale = 'column') {


  expression_matrix <- data@exp_matrix
  group_metadata <- data@metadata[[group_column]]

  combined_data <- cbind(expression_matrix, group_metadata)

  avg_marker_expressions <- combined_data %>%
    group_by(group_metadata) %>%
    summarise_all(mean, na.rm = TRUE) %>%
    select(-group_metadata) %>%
    as.matrix()

  pheatmap(avg_marker_expressions,
           clustering_distance_cols = clustering_distance,
           cluster_rows = F,
           color = colors,
           main = paste("Average Marker Expressions by", group_column),
           fontsize = fontsize,
           scale = scale,
           labels_row = unique(data@metadata[[group_column]]))
}

plotDistribution <- function(obj) {
  num_cols <- ncol(obj@exp_matrix)
  num_rows <- ceiling(num_cols / 3)

  par(mfrow = c(num_rows, 3))
  par(mar = c(2, 2, 2, 1))

  for (i in 1:num_cols) {
    hist(obj@exp_matrix[, i],  breaks = 1000,
         main = paste(colnames(obj@exp_matrix)[i]),
         xlab = "", ylab = "")  # Clear x and y labels
  }

  par(mfrow = c(1, 1))
}

runPCA <- function(obj, scale){
  pca_output <- prcomp(obj@exp_matrix, scale=scale)

  obj@metadata[['PCA_coord']] <- pca_output # figure this out
  return(obj)

}

viewPCA <- function(obj, group_column){
  ##
  y_factor <- factor(obj@metadata[[group_column]])
  coord <- as.data.frame(obj@metadata$PCA_coord[['x']])
  fig <- plot_ly(data = coord,
                 x = coord$PC1, y = coord$PC2, #z = coord$PC3,
                 color = ~y_factor,
                 colors = c("lightseagreen",
                            "gray50",
                            "darkgreen",
                            "red4",
                            "red",
                            "turquoise4",
                            "black",
                            "yellow4",
                            "royalblue1",
                            "lightcyan3",
                            "peachpuff3",
                            "khaki3",
                            "gray20",
                            "orange2",
                            "royalblue4",
                            "yellow3",
                            "gray80",
                            "darkorchid1",
                            "lawngreen",
                            "plum2",
                            "darkmagenta"),
                 type = "scatter",
                 mode = "markers",
                 marker = list(size = 2, width=2))
  fig

}

getElbowPlot <- function(obj, scale=F){
  pca_output <- prcomp(obj@exp_matrix, scale=scale)

  variance_explained <- pca_output$sdev^2 / sum(pca_output$sdev^2)
  cumulative_variance_explained <- cumsum(variance_explained)

  elbow_plot <- data.frame(PC = 1:length(cumulative_variance_explained),
                           Variance_Explained = variance_explained,
                           Cumulative_Variance_Explained = cumulative_variance_explained)

  library(ggplot2)
  ggplot(elbow_plot, aes(x = PC, y = Cumulative_Variance_Explained)) +
    geom_point() +
    geom_line() +
    xlab("Principal Component") +
    ylab("Cumulative Proportion of Variance Explained") +
    ggtitle("Elbow Plot")}



# required: rTSNE
runTSNE <- function(obj, usePCs=F, PCs=5){
  if(usePCs){
    tsne_output <- Rtsne(obj@metadata$PCA_coord[['x']][,PCs], dims = 3,  verbose = FALSE, max_iter = 25, pca=F)
    obj@metadata[['TSNE_coord']] <- tsne_output # figure this out
  }else{
    tsne_output <- Rtsne(obj@exp_matrix, dims = 3, verbose=T, pca=F)
    obj@metadata[['TSNE_coord']] <- tsne_output
  }

  return(obj)
} # shape changes everytime you cant have that!

viewtSNE <- function(obj, group_column){
  ##
  y_factor <- factor(obj@metadata[[group_column]])
  coord <- as.data.frame(obj@metadata$TSNE_coord)
  fig <- plot_ly(data = coord,
                 x = coord$V1, y = coord$V2,#, z = coord$V3,
                 color = ~y_factor,
                 colors = c("lightseagreen",
                            "gray50",
                            "darkgreen",
                            "red4",
                            "red",
                            "turquoise4",
                            "black",
                            "yellow4",
                            "royalblue1",
                            "lightcyan3",
                            "peachpuff3",
                            "khaki3",
                            "gray20",
                            "orange2",
                            "royalblue4",
                            "yellow3",
                            "gray80",
                            "darkorchid1",
                            "lawngreen",
                            "plum2",
                            "darkmagenta"),
                 type = "scatter",
                 mode = "markers",
                 marker = list(size = 2, width=2))
  fig

}

viewtSNE_3D <- function(obj, group_column){
  ##
  y_factor <- factor(obj@metadata[[group_column]])
  coord <- as.data.frame(obj@metadata$TSNE_coord)
  fig <- plot_ly(data = coord,
                 x = coord$V1, y = coord$V2, z = coord$V3,
                 color = ~y_factor,
                 colors = c("lightseagreen",
                            "gray50",
                            "darkgreen",
                            "red4",
                            "red",
                            "turquoise4",
                            "black",
                            "yellow4",
                            "royalblue1",
                            "lightcyan3",
                            "peachpuff3",
                            "khaki3",
                            "gray20",
                            "orange2",
                            "royalblue4",
                            "yellow3",
                            "gray80",
                            "darkorchid1",
                            "lawngreen",
                            "plum2",
                            "darkmagenta"),
                 type = "scatter3d",
                 mode = "markers",
                 marker = list(size = 2, width=2))
  fig

}

library(Rtsne)
library(Matrix)

runTSNE <- function(obj, usePCs = FALSE, PCs = 5, perplexity = 30, theta = 0.5, max_iter = 250) {
  if (usePCs) {
    data_input <- obj@metadata$PCA_coord[['x']][, PCs]
  } else {
    data_input <- obj@exp_matrix
  }
  
  # Sparse matrix conversion for faster computation if your data is large and sparse
  if (class(data_input) != "matrix") {
    data_input <- as.matrix(data_input)
  }
  
  tsne_output <- Rtsne(data_input, dims = 3, perplexity = perplexity, theta = theta, 
                       max_iter = max_iter, verbose = TRUE, pca = FALSE)
  
  # Store t-SNE results in obj@metadata
  obj@metadata[['TSNE_coord']] <- as.data.frame(tsne_output$Y)
  
  return(obj)
}

library(uwot)

runUMAP <- function(obj, usePCs = FALSE, PCs = 1:5, n_neighbors = 15, min_dist = 0.1, metric = "euclidean") {
  if (usePCs) {
    data_input <- obj@metadata$PCA_coord[['x']][, PCs]
  } else {
    data_input <- obj@exp_matrix
  }
  
  # UMAP computation
  umap_output <- umap(data_input, n_neighbors = n_neighbors, min_dist = min_dist, metric = metric, n_threads = parallel::detectCores() - 1)
  
  # Store UMAP results in obj@metadata
  obj@metadata[['UMAP_coord']] <- as.data.frame(umap_output)
  
  return(obj)
}


```

### Object Summary

```{r echo=FALSE, message=FALSE}
obj
# here, show cell number, gene expressions etc. 
# what kind of analysis was performed, what layer is present 
# what dim red, and clusters, and metadata summary as well 
```

### Data Exploration

This section includes heatmap of average expressions and distributions of markers. Based on the distribution, the cutoff for binary conversion can be determined. \

```{r echo=FALSE, message=FALSE}
plotAvgHeatmap(obj, group_column = "stage")
plotDistribution(obj)
```

### Marker co-localization analysis

Cygnus offers two methods of marker co-expression analysis. The first requires binary conversion, and simply concerns co-occurrence of different combinations of markers. The benefit of this analysis is that it allows statistical analysis of all possible combination of markers. 

```{r echo=FALSE, message=FALSE}
set_cutoff <- 100
# Load necessary library
library(ComplexUpset)

# 1. Copy the original expression matrix to avoid overwriting
modified_exp_matrix <- obj@exp_matrix

# 2. Set all values less than 100 to 0
modified_exp_matrix[modified_exp_matrix < 100] <- 0

# 3. Convert the modified matrix to a binary matrix
binary_matrix <- modified_exp_matrix > 0

# 4. Convert binary matrix to data frame and add row names as a column
binary_df <- as.data.frame(binary_matrix)
binary_df$sample_id <- rownames(binary_df)

# 5. Create an Upset plot showing the top 40 combinations
upset(binary_df, 
      intersect = colnames(binary_df)[-ncol(binary_df)])
```

### Marker correlation analysis

The following plot shows pearson correlation coefficients of correlation in expressions of two markers. 

```{r echo=FALSE, message=FALSE}
# Load necessary libraries
library(Hmisc)
library(corrplot)

# Compute the correlation matrix
cor_matrix <- rcorr(as.matrix(obj@exp_matrix), type = "pearson")

# Extract correlations and p-values
correlations <- cor_matrix$r
p_values <- cor_matrix$P

# Adjust p-values using the Benjamini-Hochberg method
adjusted_p <- p.adjust(as.vector(p_values), method = "BH")
dim(adjusted_p) <- dim(p_values)  # Reshape to the original matrix dimensions

# Get the upper triangle of the correlation matrix
upper_tri <- correlations[upper.tri(correlations, diag = FALSE)]

# Get the indices of the top 9 absolute correlations
top_indices <- order(abs(upper_tri), decreasing = TRUE)[1:9]

# Extract the corresponding p-values
top_correlations <- upper_tri[top_indices]
top_p_values <- adjusted_p[upper.tri(adjusted_p, diag = FALSE)][top_indices]

# Get the corresponding gene pairs
gene_names <- colnames(obj@exp_matrix)
top_gene_pairs <- which(upper.tri(correlations, diag = FALSE), arr.ind = TRUE)[top_indices, ]
top_genes <- apply(top_gene_pairs, 1, function(x) paste(gene_names[x[1]], gene_names[x[2]], sep = " vs "))

# Plot panel of correlations with small filled dots
par(mfrow = c(3, 3))  # 3x3 grid for the top 9 correlations

for (i in 1:length(top_genes)) {
  gene_pair <- top_gene_pairs[i, ]
  plot(obj@exp_matrix[, gene_pair[1]], obj@exp_matrix[, gene_pair[2]], 
       xlab = gene_names[gene_pair[1]], ylab = gene_names[gene_pair[2]], 
       main = paste(top_genes[i], "\nCorrelation: ", round(top_correlations[i], 2), 
                    "\nAdjusted p-value: ", formatC(top_p_values[i], format = "e", digits = 2)),
       pch = 20,  # 'pch = 20' sets the plotting character to a small filled dot
       cex = 0.1)  # 'cex = 0.5' reduces the size of the dots
}

par(mfrow = c(1, 1))  # Reset plotting layout


```

### Dimensionality Reduction 

```{r echo=FALSE, message=FALSE}
obj <- runPCA(obj, scale = F)
obj <- runTSNE(obj, usePCs = F)

#library(uwot)

#runUMAP <- function(obj, usePCs = FALSE, PCs = 1:5, n_neighbors = 15, min_dist = 0.1, metric = "euclidean") {
#   if (usePCs) {
#     data_input <- obj@metadata$PCA_coord[['x']][, PCs]
#   } else {
#     data_input <- obj@exp_matrix
#   }
#   
#   # UMAP computation
#   umap_output <- umap(data_input, n_neighbors = n_neighbors, min_dist = min_dist, metric = metric, n_threads = parallel::detectCores() - 1)
#   
#   # Store UMAP results in obj@metadata
#   obj@metadata[['UMAP_coord']] <- as.data.frame(umap_output)
#   
#   return(obj)
# }
#obj <- runUMAP(obj, usePCs = F)
```

**Principal Component Analysis** finds linear combinations that captures as much variability within the dataset and projects the multi-dimensional data into axes represented by those linaer combinations.  

```{r echo=FALSE, message=FALSE}
viewPCA(obj, "stage")
```

**t-distributed stochastic neighbor embedding** is a non-linear dimensionality method.  

```{r echo=FALSE, message=FALSE}
#viewtSNE(obj, "stage")
viewtSNE_3D(obj, "stage")
```



```{r echo=FALSE, message=FALSE}
###Dimensionality Reduction - UMAP
# coming soon!
```

## Clustering Analysis

The code uses mini-batch K-means clustering. The result can be visualized through dimensionality reduction plots, such as PCA, tSNE or UMAP.

```{r echo=FALSE, message=FALSE}
# Load necessary libraries
library(ClusterR)
library(parallel)

# Convert your expression matrix to a data frame (if not already)
data <- as.data.frame(obj@exp_matrix)

# Set the number of clusters (adjust as necessary)
num_clusters <- 10

# Set the number of cores to use
num_cores <- detectCores() - 1  # Leave one core free

# Perform Mini-Batch K-means clustering
mbk_means <- MiniBatchKmeans(data, clusters = num_clusters, batch_size = 1000, 
                             num_init = 5, max_iters = 100, init_fraction = 0.2, 
                             early_stop_iter = 10, verbose = FALSE,)

# Retrieve cluster assignments
cluster_assignments <- predict_MBatchKMeans(data, mbk_means$centroids)

# Check cluster sizes
table(cluster_assignments)

#fig <- viewtSNE_3D(obj, group_column = "clusters")
#fig
obj@metadata[['cluster']] <- cluster_assignments
viewtSNE_3D(obj, "cluster")


```

### Cluster Characterization

Further downstream analysis for cluster characterization includes expression heatmap, and proportions analysis. 

```{r echo=FALSE, message=FALSE}

obj@metadata$cluster <- as.data.frame(cluster_assignments)
obj@metadata$new <- obj@metadata[["cluster"]][["cluster_assignments"]]
plotAvgHeatmap(obj, "new")

```

```{r echo=FALSE, message=FALSE}

obj@metadata$stage_group <- obj@metadata$stage


obj@metadata$stage_group[obj@metadata$stage %in% c("F1", "F2", "M1")] <- "Healthy"


obj@metadata$stage_group[grepl("^T1", obj@metadata$stage)] <- "Stage 1"
obj@metadata$stage_group[grepl("^T2", obj@metadata$stage)] <- "Stage 2"

obj@metadata$stage_group[grepl("^T3", obj@metadata$stage)] <- "Stage 3"

obj@metadata$stage_group[grepl("^T4", obj@metadata$stage)] <- "Stage 4"

library(ggplot2)
library(dplyr)

subset_metadata <- data.frame(
  cluster = obj@metadata$cluster,
  stage_group = obj@metadata$stage_group
)


proportions <- subset_metadata %>%
  group_by(cluster_assignments, stage_group) %>%
  summarise(count = n()) %>%
  group_by(cluster_assignments) %>%
  mutate(proportion = count / sum(count))


ggplot(proportions, aes(x = factor(cluster_assignments), y = proportion, fill = stage_group)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Cluster", y = "Proportion", fill = "Stage Group") +
  theme_minimal() +
  theme(legend.position = "right")

```

Cygnus!
