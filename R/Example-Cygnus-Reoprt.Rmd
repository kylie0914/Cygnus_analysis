---
title: "Example Cygnus Report"
author: "Yein Chung"
date: "2024-08-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

This document is an example Cygnus Report that can be generated at the last step of Cygnus data analysis. Each plot shown in this file is generated when the corresponding R markdown file is knitted to HTML, and hence can be reused with another Cygnus data to generate a similar report. All codes are hidden in the final HTML file to simplify the report. 

```{r compute, echo=FALSE, results='hide', message=FALSE}
library(Cygnus)
library(tidyverse)
library(pheatmap)
library(plotly)
library(Rtsne)
data.path <- "/Users/yeinchung/leelab_2024/Cygnus_test/AIVIA_SEAM_HumanPatient_20231028_Values.csv"
obj <- getCygnus(data.path)
all_markers <- colnames(obj)[6:17] # specific to this data 
meta_markers <- colnames(obj)[18:19]

obj <- createCygnus(obj, all_markers, meta_markers)

plotAvgHeatmap <- function(data, group_column,
                          clustering_distance = "euclidean",
                          colors = rev(colorRampPalette(RColorBrewer::brewer.pal(n = 11, "RdYlBu"))(100)),
                          fontsize = 8,
                          scale = 'column') {


  expression_matrix <- data@exp_matrix
  group_metadata <- data@metadata[[group_column]]

  combined_data <- cbind(expression_matrix, group_metadata)

  avg_marker_expressions <- combined_data %>%
    group_by(group_metadata) %>%
    summarise_all(mean, na.rm = TRUE) %>%
    select(-group_metadata) %>%
    as.matrix()

  pheatmap(avg_marker_expressions,
           clustering_distance_cols = clustering_distance,
           cluster_rows = F,
           color = colors,
           main = paste("Average Marker Expressions by", group_column),
           fontsize = fontsize,
           scale = scale,
           labels_row = unique(data@metadata[[group_column]]))
}

plotDistribution <- function(obj) {
  num_cols <- ncol(obj@exp_matrix)
  num_rows <- ceiling(num_cols / 3)

  par(mfrow = c(num_rows, 3))
  par(mar = c(2, 2, 2, 1))

  for (i in 1:num_cols) {
    hist(obj@exp_matrix[, i],  breaks = 1000,
         main = paste(colnames(obj@exp_matrix)[i]),
         xlab = "", ylab = "")  # Clear x and y labels
  }

  par(mfrow = c(1, 1))
}

runPCA <- function(obj, scale){
  pca_output <- prcomp(obj@exp_matrix, scale=scale)

  obj@metadata[['PCA_coord']] <- pca_output # figure this out
  return(obj)

}

viewPCA <- function(obj, group_column){
  ##
  y_factor <- factor(obj@metadata[[group_column]])
  coord <- as.data.frame(obj@metadata$PCA_coord[['x']])
  fig <- plot_ly(data = coord,
                 x = coord$PC1, y = coord$PC2, #z = coord$PC3,
                 color = ~y_factor,
                 colors = c("lightseagreen",
                            "gray50",
                            "darkgreen",
                            "red4",
                            "red",
                            "turquoise4",
                            "black",
                            "yellow4",
                            "royalblue1",
                            "lightcyan3",
                            "peachpuff3",
                            "khaki3",
                            "gray20",
                            "orange2",
                            "royalblue4",
                            "yellow3",
                            "gray80",
                            "darkorchid1",
                            "lawngreen",
                            "plum2",
                            "darkmagenta"),
                 type = "scatter",
                 mode = "markers",
                 marker = list(size = 2, width=2))
  fig

}

getElbowPlot <- function(obj, scale=F){
  pca_output <- prcomp(obj@exp_matrix, scale=scale)

  variance_explained <- pca_output$sdev^2 / sum(pca_output$sdev^2)
  cumulative_variance_explained <- cumsum(variance_explained)

  elbow_plot <- data.frame(PC = 1:length(cumulative_variance_explained),
                           Variance_Explained = variance_explained,
                           Cumulative_Variance_Explained = cumulative_variance_explained)

  library(ggplot2)
  ggplot(elbow_plot, aes(x = PC, y = Cumulative_Variance_Explained)) +
    geom_point() +
    geom_line() +
    xlab("Principal Component") +
    ylab("Cumulative Proportion of Variance Explained") +
    ggtitle("Elbow Plot")}



# required: rTSNE
runTSNE <- function(obj, usePCs=F, PCs=5){
  if(usePCs){
    tsne_output <- Rtsne(obj@metadata$PCA_coord[['x']][,PCs], dims = 3,  verbose = TRUE, max_iter = 25, pca=F)
    obj@metadata[['TSNE_coord']] <- tsne_output # figure this out
  }else{
    tsne_output <- Rtsne(obj@exp_matrix, dims = 3, verbose=T, pca=F)
    obj@metadata[['TSNE_coord']] <- tsne_output
  }

  return(obj)
} # shape changes everytime you cant have that!

viewtSNE <- function(obj, group_column){
  ##
  y_factor <- factor(obj@metadata[[group_column]])
  coord <- as.data.frame(obj@metadata$TSNE_coord[['Y']])
  fig <- plot_ly(data = coord,
                 x = coord$V1, y = coord$V2,#, z = coord$V3,
                 color = ~y_factor,
                 colors = c("lightseagreen",
                            "gray50",
                            "darkgreen",
                            "red4",
                            "red",
                            "turquoise4",
                            "black",
                            "yellow4",
                            "royalblue1",
                            "lightcyan3",
                            "peachpuff3",
                            "khaki3",
                            "gray20",
                            "orange2",
                            "royalblue4",
                            "yellow3",
                            "gray80",
                            "darkorchid1",
                            "lawngreen",
                            "plum2",
                            "darkmagenta"),
                 type = "scatter",
                 mode = "markers",
                 marker = list(size = 2, width=2))
  fig

}

viewtSNE_3D <- function(obj, group_column){
  ##
  y_factor <- factor(obj@metadata[[group_column]])
  coord <- as.data.frame(obj@metadata$TSNE_coord[['Y']])
  fig <- plot_ly(data = coord,
                 x = coord$V1, y = coord$V2, z = coord$V3,
                 color = ~y_factor,
                 colors = c("lightseagreen",
                            "gray50",
                            "darkgreen",
                            "red4",
                            "red",
                            "turquoise4",
                            "black",
                            "yellow4",
                            "royalblue1",
                            "lightcyan3",
                            "peachpuff3",
                            "khaki3",
                            "gray20",
                            "orange2",
                            "royalblue4",
                            "yellow3",
                            "gray80",
                            "darkorchid1",
                            "lawngreen",
                            "plum2",
                            "darkmagenta"),
                 type = "scatter3d",
                 mode = "markers",
                 marker = list(size = 2, width=2))
  fig

}

```


## Object Summary
```{r}
obj
# here, show cell number, gene expressions etc. 
# what kind of analysis was performed, what layer is present 
# what dim red, and clusters, and metadata summary as well 
```

## Data Exploration
```{r}
plotAvgHeatmap(obj, group_column = "stage")
plotDistribution(obj)
```

## Marker Analysis 
### Marker co-localization analysis
```{r}
set_cutoff <- 100

```

### Marker correlation analysis 
```{r}
# Load necessary libraries
library(Hmisc)
library(corrplot)

# Compute the correlation matrix
cor_matrix <- rcorr(as.matrix(obj@exp_matrix), type = "pearson")

# Extract correlations and p-values
correlations <- cor_matrix$r
p_values <- cor_matrix$P

# Adjust p-values using the Benjamini-Hochberg method
adjusted_p <- p.adjust(as.vector(p_values), method = "BH")
dim(adjusted_p) <- dim(p_values)  # Reshape to the original matrix dimensions

# Get the upper triangle of the correlation matrix
upper_tri <- correlations[upper.tri(correlations, diag = FALSE)]

# Get the indices of the top 9 absolute correlations
top_indices <- order(abs(upper_tri), decreasing = TRUE)[1:9]

# Extract the corresponding p-values
top_correlations <- upper_tri[top_indices]
top_p_values <- adjusted_p[upper.tri(adjusted_p, diag = FALSE)][top_indices]

# Get the corresponding gene pairs
gene_names <- colnames(obj@exp_matrix)
top_gene_pairs <- which(upper.tri(correlations, diag = FALSE), arr.ind = TRUE)[top_indices, ]
top_genes <- apply(top_gene_pairs, 1, function(x) paste(gene_names[x[1]], gene_names[x[2]], sep = " vs "))

# Plot panel of correlations with small filled dots
par(mfrow = c(3, 3))  # 3x3 grid for the top 9 correlations

for (i in 1:length(top_genes)) {
  gene_pair <- top_gene_pairs[i, ]
  plot(obj@exp_matrix[, gene_pair[1]], obj@exp_matrix[, gene_pair[2]], 
       xlab = gene_names[gene_pair[1]], ylab = gene_names[gene_pair[2]], 
       main = paste(top_genes[i], "\nCorrelation: ", round(top_correlations[i], 2), 
                    "\nAdjusted p-value: ", formatC(top_p_values[i], format = "e", digits = 2)),
       pch = 20,  # 'pch = 20' sets the plotting character to a small filled dot
       cex = 0.5)  # 'cex = 0.5' reduces the size of the dots
}

par(mfrow = c(1, 1))  # Reset plotting layout


```

## EV analysis 
### Dimensionality Reduction - tSNE
```{r}
obj <- runPCA(obj, scale = F)
obj <- runTSNE(obj, usePCs = F)
```

PCA:
```{r}
viewPCA(obj, "stage")
```

tSNE:
```{r}
viewtSNE(obj, "stage")
viewtSNE_3D(obj, "stage")
```


### Dimensionality Reduction - UMAP
```{r}
# coming soon!
```

### Clustering Analysis 
```{r}

```

### Cluster Characterization
```{r}
# heatmap
# proportion
# line graph
```


